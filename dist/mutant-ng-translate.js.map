{"version":3,"sources":["translate.js","cache.js","directive.js","events.js","filter.js","loader-service.js","loader.js","service.js","storage-service.js","storage.js","utils.js"],"names":["angular","module","translateCache","$window","isSupportLocalStorage","localStorage","setItem","removeItem","exception","getFromLocalStorage","key","self","local","storage","JSON","parse","putToLocalStorage","obj","stringify","existsInLocalStorage","getValuesFromCache","lang","isSupported","lsKey","prefix","exists","put","get","setValuesToCache","values","cacheValues","cache","getValues","merge","getLangFromCache","setLangToCache","this","setValues","getLang","setLang","factory","translateDirective","$translate","$translateEvents","link","scope","element","attrs","translitionKey","update","innerHTML","translation","translationsUpdated","subscribe","langChanged","restrict","directive","translateEvents","$utils","partLoaded","event","allPartsLoaded","callback","disposable","undefined","error","subscriber","id","generateId","unsubscribe","subscribers","push","index","indexOf","splice","publish","data","slice","i","length","translateFilter","filter","$stateful","translateLoaderSvc","$timeout","$translateLoader","$translateUtils","config","options","storageCallback","preload","addParts","names","addPart","name","part","parts","loadPart","loadParts","force","sync","resetCounter","needLoad","loadingOn","partOptions","urlTemplate","dataTransformation","then","loadingOff","increaseCounter","checkCounter","loading","loaded","isLoading","isLoaded","counter","enabled","langs","delay","translateLoader","$http","$q","url","replace","resolve","reject","response","translate","$storage","$loader","validateOptions","setTranslations","defaultLang","translations","Object","prototype","toString","call","use","current","getTranslations","getTranslation","arguments","refresh","directDataTransformation","keyResolver","directKeyResolver","translateStorageSvc","$translateStorage","$translateCache","set","oldLang","from","to","cacheGetLang","cacheSetLang","cacheGetTranslations","cacheSetTranslations","storageGetLang","storageSetLang","storageGetTranslations","storageGetTranslation","getValue","storageSetTranslations","translateStorage","resolver","hasOwnProperty","tranlslateUtils","throw","message","Error","warning","write","console","warn"],"mappings":"CAAA,WACA,YAwIAA,SACAC,OAAA,6BC1IA,WACA,YAcA,SAAAC,GAAAC,GAgCA,QAAAC,KACA,IAIA,MAHAD,GAAAE,aAAAC,QAAA,OAAA,QACAH,EAAAE,aAAAE,WAAA,SAEA,EACA,MAAAC,GACA,OAAA,GAeA,QAAAC,GAAAC,GACA,GAAAC,EAAAC,MAAAC,QAAAH,GACA,MAAAI,MAAAC,MAAAJ,EAAAC,MAAAC,QAAAH,IAcA,QAAAM,GAAAN,EAAAO,GACAN,EAAAC,MAAAC,QAAAH,GAAAI,KAAAI,UAAAD,GAcA,QAAAE,GAAAT,GACA,QAAAC,EAAAC,MAAAC,QAAAH,GAgBA,QAAAU,GAAAC,GACA,IAAAV,EAAAC,MAAAU,YAAA,QAEA,IAAAC,GAAAZ,EAAAC,MAAAY,OAAAH,CAMA,OAJAV,GAAAC,MAAAa,OAAAF,IACAZ,EAAAC,MAAAc,IAAAH,MAGAZ,EAAAC,MAAAe,IAAAJ,GAeA,QAAAK,GAAAP,EAAAQ,GACA,GAAAlB,EAAAC,MAAAU,YAAA,CAEA,GAAAC,GAAAZ,EAAAC,MAAAY,OAAAH,EACAS,EAAAnB,EAAAoB,MAAAC,UAAAX,EAEArB,SAAAiC,MAAAH,EAAAD,GAEAlB,EAAAC,MAAAc,IAAAH,EAAAO,IAcA,QAAAI,KACA,GAAAvB,EAAAC,MAAAU,YAAA,CAEA,GAAAC,GAAAZ,EAAAC,MAAAY,OAAA,MAEA,OAAAb,GAAAC,MAAAe,IAAAJ,IAcA,QAAAY,GAAAd,GACA,GAAAV,EAAAC,MAAAU,YAAA,CAEA,GAAAC,GAAAZ,EAAAC,MAAAY,OAAA,MAEAb,GAAAC,MAAAc,IAAAH,EAAAF,IA3KA,GAAAV,GAAAyB,IAkBA,OAhBAzB,GAAAC,OACAY,OAAA,uBACAF,YAAAlB,IACAS,QAAAV,EAAAE,aACAsB,IAAAlB,EACAiB,IAAAV,EACAS,OAAAN,GAGAR,EAAAoB,OACAC,UAAAZ,EACAiB,UAAAT,EACAU,QAAAJ,EACAK,QAAAJ,GAGAxB,EAAAoB,MA/BA/B,QACAC,OAAA,uBACAuC,QAAA,mBAAA,UAAAtC,OCLA,WACA,YAoBA,SAAAuC,GAAAC,EAAAC,GACA,GAAAC,GAAA,SAAAC,EAAAC,EAAAC,GACAD,EAAAA,EAAA,EAEA,IAAAE,GAAAD,EAAA,YAEAE,EAAA,WACAH,EAAAI,UAAAR,EAAAS,YAAAH,GAGAL,GAAAS,oBAAAC,UAAAJ,GACAN,EAAAW,YAAAD,UAAAJ,GAEAH,EAAAI,UAAAR,EAAAS,YAAAH,GAGA,QACAO,SAAA,IACAX,KAAAA,GApCA5C,QACAC,OAAA,uBACAuD,UAAA,eAAA,aAAA,mBAAAf,OCLA,WACA,YA6BA,SAAAgB,GAAAC,GACA,GAAA/C,GAAAyB,IAkDA,OAtCAzB,GAAAgD,WAAA,GAAAC,GAAAF,GAYA/C,EAAAkD,eAAA,GAAAD,GAAAF,GAYA/C,EAAAyC,oBAAA,GAAAQ,GAAAF,GAYA/C,EAAA2C,YAAA,GAAAM,GAAAF,GAEA/C,EAWA,QAAAiD,GAAAF,GA8BA,QAAAL,GAAAS,EAAAC,GACAC,QAAAF,EACAJ,EAAAO,MAAAP,SAAA,sDACA,kBAAAI,IACAJ,EAAAO,MAAAP,SAAA,wDAGA,IAAAQ,IACAC,GAAAxD,EAAAyD,aACAN,SAAAC,EACA,WACAG,EAAAG,cACAP,KAEAA,EACAO,YAAA1D,EAAA0D,YAKA,OAFA1D,GAAA2D,YAAAC,KAAAL,GAEAA,EAaA,QAAAG,KACA,GAAAG,GAAA7D,EAAA2D,YAAAG,QAAArC,KACA,OAAAoC,UAEA7D,EAAA2D,YAAAI,OAAAF,EAAA,IACA,GAaA,QAAAG,GAAAC,GAGA,IAAA,GAFAN,GAAA3D,EAAA2D,YAAAO,QAEAC,EAAA,EAAAA,EAAAR,EAAAS,OAAAD,IACAR,EAAAQ,GAAAhB,SAAAc,GAcA,QAAAR,KACA,MAAAzD,GAAAwD,KAnGA,GAAAxD,GAAAyB,IAUA,OARAzB,GAAA2D,eACA3D,EAAA0C,UAAAA,EACA1C,EAAA0D,YAAAA,EACA1D,EAAAgE,QAAAA,EAEAhE,EAAAwD,GAAA,EACAxD,EAAAyD,WAAAA,GAGAf,UAAA1C,EAAA0C,UACAsB,QAAAhE,EAAAgE,SAtGA3E,QACAC,OAAA,uBACAuC,QAAA,oBAAA,kBAAAiB,OCLA,WACA,YAiBA,SAAAuB,GAAAtC,GACA,GAAAuC,GAAA,SAAAvE,GACA,MAAAgC,GAAAS,YAAAzC,GAKA,OAFAuE,GAAAC,WAAA,EAEAD,EAtBAjF,QACAC,OAAA,uBACAgF,OAAA,aAAA,aAAAD,OCLA,WACA,YAiBA,SAAAG,GAAAC,EAAAC,EAAA1C,EAAA2C,GAmDA,QAAAC,GAAAC,EAAAC,GACA9E,EAAA6E,QAAAA,EACA7E,EAAA8E,gBAAAA,EAEA9C,EAAAkB,eAAAR,UAAA1C,EAAA+E,SAAA,GAeA,QAAAC,GAAAC,EAAAvE,GACA,IAAA,GAAAyD,GAAA,EAAAA,EAAAc,EAAAb,OAAAD,IACAnE,EAAAkF,QAAAD,EAAAd,GAAAzD,GAeA,QAAAwE,GAAAC,EAAAzE,GACA,gBAAAyE,IACAR,EAAArB,MAAAqB,SAAA,gCAKA,KAAA,GAFAS,IAAAD,KAAAA,GAEAhB,EAAA,EAAAA,EAAAnE,EAAAqF,MAAAjB,OAAAD,IACA,GAAAnE,EAAAqF,MAAAlB,GAAAgB,OAAAC,EAAAD,KAAA,MAGAnF,GAAAqF,MAAAvB,QAAAsB,UAEApF,EAAAqF,MAAAzB,KAAAwB,GAEApF,EAAAsF,SAAAF,EAAA1E,IAiBA,QAAA6E,GAAA7E,EAAA8E,GACAA,GACAxF,EAAAyF,KAAAC,aAAAhF,EAGA,KAAA,GAAAyD,GAAA,EAAAA,EAAAnE,EAAAqF,MAAAjB,OAAAD,KACAqB,GAAAxF,EAAAyF,KAAAE,SAAA3F,EAAAqF,MAAAlB,GAAAzD,KAEAV,EAAAsF,SAAAtF,EAAAqF,MAAAlB,GAAAzD,GAiBA,QAAA4E,GAAAF,EAAA1E,GACAV,EAAAyF,KAAAG,UAAAR,EAAA1E,EAEA,IAAAmF,IACAT,KAAAA,EACA1E,KAAAA,EACAoF,YAAA9F,EAAA6E,QAAAiB,YACAC,mBAAA/F,EAAA6E,QAAAkB,mBAGArB,GACAY,SAAAO,GACAG,KAAA,SAAA9E,GACAlB,EAAAyF,KAAAQ,WAAAb,EAAA1E,GACAV,EAAAyF,KAAAS,gBAAAxF,GACAV,EAAAyF,KAAAU,aAAAzF,GAEAV,EAAA8E,gBAAApE,EAAAQ,GAEAc,EAAAgB,WAAAgB,SAAAoB,KAAAA,EAAAD,KAAAzE,KAAAA,MAgBA,QAAAkF,GAAAR,EAAA1E,GACAV,EAAAyF,KAAAW,QAAA1F,EAAA,IAAA0E,EAAAD,OAAA,EAcA,QAAAc,GAAAb,EAAA1E,GACAV,EAAAyF,KAAAW,QAAA1F,EAAA,IAAA0E,EAAAD,OAAA,EACAnF,EAAAyF,KAAAY,OAAA3F,EAAA,IAAA0E,EAAAD,OAAA,EAcA,QAAAmB,GAAAlB,EAAA1E,GACA,MAAAV,GAAAyF,KAAAW,QAAA1F,EAAA,IAAA0E,EAAAD,MAeA,QAAAoB,GAAAnB,EAAA1E,GACA,QAAAV,EAAAyF,KAAAY,OAAA3F,EAAA,IAAA0E,EAAAD,MAaA,QAAAe,GAAAxF,GACAV,EAAAyF,KAAAe,QAAA9F,GACAV,EAAAyF,KAAAe,QAAA9F,KADAV,EAAAyF,KAAAe,QAAA9F,GAAA,EAcA,QAAAgF,GAAAhF,GACAV,EAAAyF,KAAAe,QAAA9F,GAAA,EAaA,QAAAyF,GAAAzF,GACAV,EAAAyF,KAAAe,QAAA9F,KAAAV,EAAAqF,MAAAjB,QAEApC,EAAAkB,eAAAc,SAAAtD,KAAAA,IAgBA,QAAAiF,GAAAP,EAAA1E,GACA,OAAA4F,EAAAlB,EAAA1E,KAAA6F,EAAAnB,EAAA1E,GAcA,QAAAqE,KACA/E,EAAA6E,QAAAE,QAAA0B,SAAAzG,EAAA6E,QAAAE,QAAA2B,OAEAjC,EAAA,WACA,IAAA,GAAAN,GAAA,EAAAA,EAAAnE,EAAA6E,QAAAE,QAAA2B,MAAAtC,OAAAD,IAAA,CACA,GAAAzD,GAAAV,EAAA6E,QAAAE,QAAA2B,MAAAvC,EAEAnE,GAAAuF,UAAA7E,KAEAV,EAAA6E,QAAAE,QAAA4B,OAvTA,GAAA3G,GAAAyB,IAgCA,OA9BAzB,GAAA4E,OAAAA,EACA5E,EAAA6E,QAAAxB,OACArD,EAAA8E,gBAAAzB,OAEArD,EAAAqF,SAEArF,EAAAgF,SAAAA,EACAhF,EAAAkF,QAAAA,EAEAlF,EAAAuF,UAAAA,EACAvF,EAAAsF,SAAAA,EAEAtF,EAAAyF,MACAe,WACAJ,WACAC,UAEAT,UAAAA,EACAK,WAAAA,EACAK,UAAAA,EACAC,SAAAA,EACAZ,SAAAA,EAEAO,gBAAAA,EACAR,aAAAA,EACAS,aAAAA,GAGAnG,EAAA+E,QAAAA,EAEA/E,EAhDAX,QACAC,OAAA,uBACAuC,QAAA,uBAAA,WAAA,mBAAA,mBAAA,kBAAA2C,OCLA,WACA,YAeA,SAAAoC,GAAAC,EAAAC,GAqBA,QAAAxB,GAAAT,GACA,GAAAkC,GAAAlC,EACAiB,YACAkB,QAAA,UAAAnC,EAAAO,KAAAD,MACA6B,QAAA,UAAAnC,EAAAnE,KAEA,OAAAoG,GAAA,SAAAG,EAAAC,GACAL,EACA7F,IAAA+F,GACAf,KAAA,SAAAmB,GACA,GAAAjG,GAAA2D,EAAAkB,mBAAAoB,EAAAlD,KACAgD,GAAA/F,KAJA2F,SAMA,SAAAvD,GACA4D,EAAA5D,OAlCA,GAAAtD,GAAAyB,IAIA,OAFAzB,GAAAsF,SAAAA,EAEAtF,EAlBAX,QACAC,OAAA,uBACAuC,QAAA,oBAAA,QAAA,KAAA+E,OCLA,WACA,YAgBA,SAAAQ,GAAAC,EAAAC,EAAAvE,GA6CA,QAAA6B,GAAAC,GACAxF,QAAAiC,MAAAtB,EAAA6E,QAAAA,GACA7E,EAAAuH,gBAAAvH,EAAA6E,SAEAwC,EAAAzC,OAAA5E,EAAA6E,SACAyC,EAAA1C,OAAA5E,EAAA6E,QAAAwC,EAAAG,iBAaA,QAAAD,GAAA1C,GAEAA,EAAA4C,aACA1E,EAAAO,MAAAP,SAAA,uCAGA,gBAAA8B,GAAA4C,aACA1E,EAAAO,MAAAP,SAAA,wCAIA8B,EAAAiB,aACA/C,EAAAO,MAAAP,SAAA,mCAGA,gBAAA8B,GAAAiB,aACA/C,EAAAO,MAAAP,SAAA,gCAGA8B,EAAAiB,YAAAhC,QAAA,gBACAf,EAAAO,MAAAP,SAAA,0DAIA,kBAAA8B,GAAAkB,oBACAhD,EAAAO,MAAAP,SAAA,2CAIA,gBAAA8B,GAAAzD,OACA2B,EAAAO,MAAAP,SAAA,6BAGA,iBAAA8B,GAAAzD,MAAAsG,cACA3E,EAAAO,MAAAP,SAAA,0CAGA,iBAAA8B,GAAAzD,MAAAV,MACAqC,EAAAO,MAAAP,SAAA,sCAIA,gBAAA8B,GAAAE,SACAhC,EAAAO,MAAAP,SAAA,+BAGA,iBAAA8B,GAAAE,QAAA0B,SACA1D,EAAAO,MAAAP,SAAA,uCAGA,mBAAA4E,OAAAC,UAAAC,SAAAC,KAAAjD,EAAAE,QAAA2B,QACA3D,EAAAO,MAAAP,SAAA,qCAGA,gBAAA8B,GAAAE,QAAA4B,OACA5D,EAAAO,MAAAP,SAAA,qCAgBA,QAAAgF,GAAArH,GACA,gBAAAA,IACAqC,EAAAO,MAAAP,SAAA,mCAGAsE,EAAA1F,YAAAjB,IAEA2G,EAAAzF,QAAAlB,GACA4G,EAAA/B,UAAA7E,GAAA,IAaA,QAAAsH,KACA,MAAAX,GAAA1F,UAwCA,QAAA+F,GAAAhH,EAAAQ,GASA,MARAR,KACAA,EAAA2G,EAAA1F,WAGAT,GACAmG,EAAAG,gBAAA9G,EAAAQ,GAGAmG,EAAAY,gBAAAvH,GAcA,QAAA8B,GAAAzC,GACA,GAAAW,GAAA2G,EAAA1F,SAEA,OAAA0F,GAAAa,eAAAxH,EAAAX,GAkBA,QAAAiF,KACA,GAAAtE,GAAA2G,EAAA1F,SAEA2F,GAAAtC,SAAAmD,UAAAzH,GAcA,QAAAwE,GAAAC,GACA,GAAAzE,GAAA2G,EAAA1F,SAEA2F,GAAApC,QAAAC,EAAAzE,GAaA,QAAA0H,GAAA5C,GACA,GAAA9E,GAAA2G,EAAA1F,SAEA2F,GAAA/B,UAAA7E,EAAA8E,GAnRA,GAAAxF,GAAAyB,IA8BA,OA5BAzB,GAAA6E,SACAkB,mBAAAhD,EAAAsF,yBACAC,YAAAvF,EAAAwF,kBACAnH,OACAsG,cAAA,EACAhH,MAAA,GAEAqE,SACA0B,SAAA,EACAC,SACAC,MAAA,IAIA3G,EAAA4E,OAAAA,EACA5E,EAAAuH,gBAAAA,EAEAvH,EAAA+H,IAAAA,EACA/H,EAAAgI,QAAAA,EAEAhI,EAAA0H,aAAAA,EACA1H,EAAAwC,YAAAA,EAEAxC,EAAAkF,QAAAA,EACAlF,EAAAgF,SAAAA,EAEAhF,EAAAoI,QAAAA,EAEApI,EA7CAX,QACAC,OAAA,uBACAuC,QAAA,cAAA,uBAAA,sBAAA,kBAAAuF,OCLA,WACA,YAgBA,SAAAoB,GAAAC,EAAAC,EAAA1G,GAmDA,QAAA4C,GAAAC,GACA7E,EAAA6E,QAAAA,CAEA,IAAAnE,GAAAV,EAAAoB,MAAAJ,IAAAN,OACAgH,EAAA1H,EAAAoB,MAAAJ,IAAA0G,aAAAhH,EAEAV,GAAAE,QAAAyI,IAAAjI,KAAAA,GACAV,EAAAE,QAAAyI,IAAAjB,aAAAhH,EAAAgH,GAgBA,QAAAF,GAAA9G,EAAAQ,GACAlB,EAAAE,QAAAyI,IAAAjB,aAAAhH,EAAAQ,GACAlB,EAAAoB,MAAAuH,IAAAjB,aAAAhH,EAAAQ,GAEAc,EAAAS,oBAAAuB,SAAAtD,KAAAA,IAcA,QAAAuH,GAAAvH,GACA,MAAAV,GAAAE,QAAAc,IAAA0G,aAAAhH,GAgBA,QAAAwH,GAAAxH,EAAAX,GACA,MAAAC,GAAAE,QAAAc,IAAAwB,YAAA9B,EAAAX,GAgBA,QAAA6B,GAAAlB,GACA,GAAAkI,GAAA5I,EAAAE,QAAAc,IAAAN,MAKA,IAHAV,EAAAE,QAAAyI,IAAAjI,KAAAA,GACAV,EAAAoB,MAAAuH,IAAAjI,KAAAA,IAEA+H,EAAA3H,OAAAJ,GAAA,CACA,GAAAgH,GAAA1H,EAAAoB,MAAAJ,IAAA0G,aAAAhH,EACAV,GAAAE,QAAAyI,IAAAjB,aAAAhH,EAAAgH,GAGA1F,EAAAW,YAAAqB,SAAA6E,KAAAD,EAAAE,GAAApI,IAaA,QAAAiB,KACA,MAAA3B,GAAAE,QAAAc,IAAAN,OAeA,QAAAqI,KACA,GAAArI,GAAA2C,MAUA,OARArD,GAAA6E,QAAAzD,MAAAV,OACAA,EAAAgI,EAAA/G,WAGAjB,IACAA,EAAAV,EAAA6E,QAAA4C,aAGA/G,EAaA,QAAAsI,GAAAtI,GACAV,EAAA6E,QAAAzD,MAAAV,MAEAgI,EAAA9G,QAAAlB,GAeA,QAAAuI,GAAAvI,GACA,MAAAV,GAAA6E,QAAAzD,MAAAsG,aAEAgB,EAAArH,UAAAX,MAcA,QAAAwI,GAAAxI,EAAAQ,GACAlB,EAAA6E,QAAAzD,MAAAsG,cAEAgB,EAAAhH,UAAAhB,EAAAQ,GAcA,QAAAiI,KACA,MAAAnJ,GAAA6E,QAAAnE,KAaA,QAAA0I,GAAA1I,GACAV,EAAA6E,QAAAnE,KAAAA,EAcA,QAAA2I,GAAA3I,GACA,MAAA+H,GAAApH,UAAAX,GAeA,QAAA4I,GAAA5I,EAAAX,GACA,MAAA0I,GAAAc,SAAA7I,EAAAX,EAAAC,EAAA6E,QAAAyD,aAcA,QAAAkB,GAAA9I,EAAAQ,GACAuH,EAAA/G,UAAAhB,EAAAQ,GA9SA,GAAAlB,GAAAyB,IAmCA,OAjCAzB,GAAA4E,OAAAA,EACA5E,EAAA6E,QAAAxB,OAEArD,EAAAoB,OACAJ,KACAN,KAAAqI,EACArB,aAAAuB,GAEAN,KACAjI,KAAAsI,EACAtB,aAAAwB,IAIAlJ,EAAAE,SACAc,KACAN,KAAAyI,EACAzB,aAAA2B,EACA7G,YAAA8G,GAEAX,KACAjI,KAAA0I,EACA1B,aAAA8B,IAIAxJ,EAAAwH,gBAAAA,EACAxH,EAAAiI,gBAAAA,EACAjI,EAAAkI,eAAAA,EAEAlI,EAAA4B,QAAAA,EACA5B,EAAA2B,QAAAA,EAEA3B,EAlDAX,QACAC,OAAA,uBACAuC,QAAA,wBAAA,oBAAA,kBAAA,mBAAA2G,OCLA,WACA,YAaA,SAAAiB,KAwBA,QAAApI,GAAAX,GAKA,MAJAV,GAAAc,OAAAJ,KACAV,EAAA0G,MAAAhG,OAGAV,EAAA0G,MAAAhG,GAeA,QAAA6I,GAAA7I,EAAAX,EAAA2J,GACA,MAAA1J,GAAAc,OAAAJ,EAAAX,GAQAC,EAAA0G,MAAAhG,GAAAX,GAPA,kBAAA2J,GACAA,EAAA3J,GAEAA,EAmBA,QAAA2B,GAAAhB,EAAAQ,GACAlB,EAAA0G,MAAAiD,eAAAjJ,KACAV,EAAA0G,MAAAhG,OAGArB,QAAAiC,MAAAtB,EAAA0G,MAAAhG,GAAAQ,GAeA,QAAAJ,GAAAJ,EAAAX,GACA,QAAAC,EAAA0G,MAAAiD,eAAAjJ,MAEAX,IAAAC,EAAA0G,MAAAhG,GAAAiJ,eAAA5J,IA1FA,GAAAC,GAAAyB,IAUA,OARAzB,GAAA0G,SAEA1G,EAAAqB,UAAAA,EACArB,EAAAuJ,SAAAA,EACAvJ,EAAA0B,UAAAA,EAEA1B,EAAAc,OAAAA,EAEAd,EAtBAX,QACAC,OAAA,uBACAuC,QAAA,qBAAA4H,OCLA,WACA,YAaA,SAAAG,KACA,GAAA5J,GAAAyB,IA8EA,OAhEAzB,GAAAqI,yBAAA,SAAAnH,GACA,MAAAA,IAeAlB,EAAAuI,kBAAA,SAAAxI,GACA,MAAAA,IAgBAC,EAAAsD,OACAzC,OAAA,0BACAgJ,QAAA,SAAAC,GACA,KAAA,IAAAC,OAAA/J,EAAAsD,MAAAzC,OAAAiJ,KAiBA9J,EAAAgK,SACAC,MAAA5G,QAAA6G,SACA7G,QAAA6G,QAAAC,MACA,kBAAAD,SAAAC,KACAD,QAAAC,KACA,aACAN,QAAA,SAAAC,GACA9J,EAAAgK,QAAAC,MAAAjK,EAAAsD,MAAAzC,OAAAiJ,KAIA9J,EA1FAX,QACAC,OAAA,uBACAuC,QAAA,mBAAA+H","file":"mutant-ng-translate.js","sourcesContent":["(function () {\r\n    'use strict';\r\n\r\n    /**\r\n     * @ngdoc overview\r\n     * @name translate\r\n     * \r\n     * @description \r\n     * # MUTANT-NG-TRANSLATE \r\n     * ## General \r\n     * \r\n     * Internationalization library for Angular applications.  \r\n     * \r\n     * For quick start look to official {@link https://github.com/accetone/mutant-ng-translate readme file}.  \r\n     * Also you can find simple demo {@link http://accetone.github.io/mutant-ng-translate-docs/demo/ here}.  \r\n     * \r\n     * **Our key features**\r\n     * - native parts mechanism: load your locale files using complex url templates like `/locale-{part}-{lang}.json`  \r\n     * - parallel asynchronous loading: translations from part will be available and showed as soon as loaded  \r\n     * - built-in caching of loaded translations and choosed language using browser localstorage, \r\n     * so next time user will see translations imidiatelly  \r\n     * - configurable preload that load languages after primary language loaded,\r\n     * so you can make switch of language more gentle  \r\n     * \r\n     * ## Config options\r\n     * \r\n     * **Required options**  \r\n     * \r\n     * Url template and default language are only required.\r\n     * Other options are optional.\r\n     * \r\n     * ```javascript\r\n     * $translate.config({\r\n     *      defaultLang: 'en',\r\n     *      urlTemplate: '/locale-{part}-{lang}.json'\r\n     * });\r\n     * ```\r\n     * \r\n     * **One file per language**\r\n     * \r\n     * Url template should contain at least `{lang}` pattern. \r\n     * So if you have only one file per language, you can specify required template.\r\n     * \r\n     * ```javascript\r\n     * $translate.config({\r\n     *      defaultLang: 'en',\r\n     *      urlTemplate: '/locale/{lang}.json'\r\n     * });\r\n     * \r\n     * $translate.addPart('');\r\n     * ```\r\n     * \r\n     * **Complex JSON file**\r\n     * \r\n     * If your locale file not plain key-value file, you can pass `dataTransformation` function with options.\r\n     * This function should transfrom you data to plain key-value object (hashmap).\r\n     * You can find signature {@link translate.utils here} (see `directDataTransformation`). \r\n     * \r\n     * ```javascript\r\n     * $translate.config({\r\n     *      ...\r\n     *      dataTranformation: funciton (data) {\r\n     *          return data.translations;       \r\n     *      }\r\n     * });\r\n     * ```\r\n     * \r\n     * **Custom non existing translations**\r\n     * \r\n     * By default you will see `key` if translation for this `key` not exist for current language.\r\n     * If you want to change this behaviour you can pass `keyResolver` function with options.\r\n     * This function should receive `key` and return default translation.\r\n     * You can find signature {@link translate.utils here} (see `directKeyResolver`). \r\n     * \r\n     * ```javascript\r\n     * $translate.config({\r\n     *      ...\r\n     *      keyResolver: funciton (key) {\r\n     *          return '';     \r\n     *      }\r\n     * });\r\n     * ```\r\n     * \r\n     * **Disable cache**\r\n     * \r\n     * If you want to disable cache of translations or preferred language in client localstorage\r\n     * you can pass `cache` object with options.\r\n     * \r\n     * ```javascript\r\n     * $translate.config({\r\n     *      ...\r\n     *      cache: {          \r\n     *          lang: false,\r\n     * \r\n     *          // not required to write, default value already true\r\n     *          translations: true\r\n     *      }\r\n     * });\r\n     * ```\r\n     * \r\n     * **Preload**\r\n     * \r\n     * You can pass list of languages that will be loaded after first language \r\n     * (in most times it would be default or preferred). \r\n     * This feature can make swithing of languages more smooth.\r\n     * Don't worry, already loaded languages will not load twice.\r\n     * \r\n     * ```javascript\r\n     * $translate.config({\r\n     *      ...\r\n     *      preload: {\r\n     *          langs: ['en', 'fr', 'de']\r\n     *      }\r\n     * });\r\n     * ```\r\n     * \r\n     * Also you can configure preload delay - \r\n     * time after first language loaded and start loading preload languages.\r\n     * \r\n     * ```javascript\r\n     * $translate.config({\r\n     *      ...\r\n     *      preload: {\r\n     *          langs: ['en', 'fr', 'de'],\r\n     * \r\n     *          // in milliseconds\r\n     *          delay: 10000\r\n     *      }\r\n     * });\r\n     * ```\r\n     * \r\n     * **Events**  \r\n     * \r\n     * If you want you can subscribe to library events.\r\n     * More information you can find {@link translate.events here}\r\n     * \r\n     */\r\n    angular\r\n        .module('mutant-ng-translate', []);\r\n})();\r\n","(function () {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .factory('$translateCache', ['$window', translateCache]);\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name translate.cache\r\n     * @requires $window\r\n     * \r\n     * @description \r\n     * Service responsible for caching the translations data and prefered language in local storage, if it supported by browser\r\n     */\r\n    function translateCache($window) {\r\n        var self = this;\r\n\r\n        self.local = {\r\n            prefix: 'mutant-ng-translate-',\r\n            isSupported: isSupportLocalStorage(),\r\n            storage: $window.localStorage,\r\n            get: getFromLocalStorage,\r\n            put: putToLocalStorage,\r\n            exists: existsInLocalStorage\r\n        };\r\n\r\n        self.cache = {\r\n            getValues: getValuesFromCache,\r\n            setValues: setValuesToCache,\r\n            getLang: getLangFromCache,\r\n            setLang: setLangToCache\r\n        };\r\n\r\n        return self.cache;\r\n\r\n        // LOCAL STORAGE\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.cache\r\n         * @name isSupportLocalStorage\r\n         * \r\n         * @returns {boolean} Is Support\r\n         * \r\n         * @description \r\n         * Check if browser support localstorage\r\n         */\r\n        function isSupportLocalStorage() {\r\n            try {\r\n                $window.localStorage.setItem('test', 'test');\r\n                $window.localStorage.removeItem('test');\r\n\r\n                return true;\r\n            } catch (exception) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.cache\r\n         * @name getFromLocalStorage\r\n         * \r\n         * @param {string} key Key\r\n         * @returns {Object | string} Value\r\n         * \r\n         * @description \r\n         * Get value by given key from local storage\r\n         */\r\n        function getFromLocalStorage(key) {\r\n            if (!self.local.storage[key]) return undefined;\r\n            return JSON.parse(self.local.storage[key]);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.cache\r\n         * @name putToLocalStorage\r\n         * \r\n         * @param {string} key Key\r\n         * @param {Object | string} obj Object\r\n         * \r\n         * @description \r\n         * Put value into local storage by given key\r\n         */\r\n        function putToLocalStorage(key, obj) {\r\n            self.local.storage[key] = JSON.stringify(obj);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.cache\r\n         * @name existsInLocalStorage\r\n         * \r\n         * @param {string} key Key\r\n         * @returns {boolean} Is Exists\r\n         * \r\n         * @description \r\n         * Check if given key exists in local storage\r\n         */\r\n        function existsInLocalStorage(key) {\r\n            return !!self.local.storage[key];\r\n        }\r\n\r\n        // CACHE\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.cache\r\n         * @name getValuesFromCache\r\n         * \r\n         * @param {string} lang Language\r\n         * @returns {Object<string, string>} Values Hashmap\r\n         * \r\n         * @description \r\n         * Return values hashmap from local storage for given language.\r\n         * If local storage not supported or hashmap for given language not exists will return empty object\r\n         */\r\n        function getValuesFromCache(lang) {\r\n            if (!self.local.isSupported) return {};\r\n\r\n            var lsKey = self.local.prefix + lang;\r\n\r\n            if (!self.local.exists(lsKey)) {\r\n                self.local.put(lsKey, {});\r\n            }\r\n\r\n            return self.local.get(lsKey);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.cache\r\n         * @name setValuesToCache\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {Object<string, string>} values Values Hashmap\r\n         * \r\n         * @description \r\n         * Merge local storage hashmap for given language with passed hashmap and put result to local storage.\r\n         * If local storage not supported will do nothing\r\n         */\r\n        function setValuesToCache(lang, values) {\r\n            if (!self.local.isSupported) return;\r\n\r\n            var lsKey = self.local.prefix + lang;\r\n            var cacheValues = self.cache.getValues(lang);\r\n\r\n            angular.merge(cacheValues, values);\r\n\r\n            self.local.put(lsKey, cacheValues);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.cache\r\n         * @name getLangFromCache\r\n         * \r\n         * @returns {string | undefined} Language\r\n         * \r\n         * @description \r\n         * Return langugage from local storage.\r\n         * If local storage not supported or language not exists in local storage will return undefined\r\n         */\r\n        function getLangFromCache() {\r\n            if (!self.local.isSupported) return undefined;\r\n\r\n            var lsKey = self.local.prefix + 'lang';\r\n\r\n            return self.local.get(lsKey);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.cache\r\n         * @name setLangToCache\r\n         * \r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Put language to local storage.\r\n         * If local storage not supported will do nothing\r\n         */\r\n        function setLangToCache(lang) {\r\n            if (!self.local.isSupported) return;\r\n\r\n            var lsKey = self.local.prefix + 'lang';\r\n\r\n            self.local.put(lsKey, lang);\r\n        }\r\n    };\r\n})();","(function () {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .directive('ngTranslate', ['$translate', '$translateEvents', translateDirective]);\r\n\r\n    /**\r\n     * @ngdoc directive\r\n     * @name translate.directive:ngTranslate\r\n     * @restrict 'A'\r\n     * @element ANY\r\n     * @requires translate.$translate\r\n     * @requires translate.events\r\n     * \r\n     * @param {string} ngTranslate Translation key\r\n     * \r\n     * @description \r\n     * Transform any html element to the translation container. \r\n     * Translations get from {@link translate.$translate $translate} service by specified key\r\n     */\r\n    function translateDirective($translate, $translateEvents) {\r\n        var link = function (scope, element, attrs) {\r\n            element = element[0];\r\n\r\n            var translitionKey = attrs['ngTranslate'];\r\n\r\n            var update = function() {\r\n                element.innerHTML = $translate.translation(translitionKey);\r\n            };\r\n\r\n            $translateEvents.translationsUpdated.subscribe(update);\r\n            $translateEvents.langChanged.subscribe(update);\r\n\r\n            element.innerHTML = $translate.translation(translitionKey);\r\n        };\r\n\r\n        return {\r\n            restrict: 'A',\r\n            link: link\r\n        };\r\n    };\r\n})();","(function () {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .factory('$translateEvents', ['$translateUtils', translateEvents]);\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name translate.events\r\n     * @requires translate.utils\r\n     * \r\n     * @description \r\n     * Service responsible for providing access to library events. \r\n     * Provide list of event objects and you can subscribe to each (see implementation {@link translate.event here}). \r\n     * \r\n     * @example\r\n     * ```javascript\r\n     * var callback = function (data) { console.log(data); }\r\n     * \r\n     * // how subscribe ?\r\n     * var token = $translateEvents.langChanged.subscribe(callback);\r\n     * \r\n     * // how unsibscribe ?\r\n     * token.unsibscribe();\r\n     * \r\n     * // how to register one-time callback ?\r\n     * var token2 = $translateEvents.langChanged.subscribe(callback, true);\r\n     * ```\r\n     */\r\n    function translateEvents($utils) {\r\n        var self = this;\r\n\r\n        /**\r\n         * @ngdoc event\r\n         * @eventOf translate.events\r\n         * @name partLoaded\r\n         * \r\n         * @param {string} data { part: partname, lang: language key }\r\n         * \r\n         * @description \r\n         * Fires when any part for any language loaded\r\n         */\r\n        self.partLoaded = new event($utils);\r\n\r\n        /**\r\n         * @ngdoc event\r\n         * @eventOf translate.events\r\n         * @name allPartsLoaded\r\n         * \r\n         * @param {string} data { lang: language key }\r\n         * \r\n         * @description \r\n         * Fires when all registered parts for some language loaded\r\n         */\r\n        self.allPartsLoaded = new event($utils);\r\n\r\n        /**\r\n         * @ngdoc event\r\n         * @eventOf translate.events\r\n         * @name translationsUpdated\r\n         * \r\n         * @param {string} data { lang: language key }\r\n         * \r\n         * @description \r\n         * Fires when translations for any language updated\r\n         */\r\n        self.translationsUpdated = new event($utils);\r\n\r\n        /**\r\n         * @ngdoc event\r\n         * @eventOf translate.events\r\n         * @name langChanged\r\n         * \r\n         * @param {string} data { from: old language key, to: new language key }\r\n         * \r\n         * @description \r\n         * Fires when language changed\r\n         */\r\n        self.langChanged = new event($utils);\r\n\r\n        return self;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name translate.event\r\n     * @requires translate.utils\r\n     * \r\n     * @description\r\n     * Used to create event objects in {@link translate.events}\r\n     */\r\n    function event($utils) {\r\n        var self = this;\r\n       \r\n        self.subscribers = [];\r\n        self.subscribe = subscribe;\r\n        self.unsubscribe = unsubscribe;\r\n        self.publish = publish;\r\n\r\n        self.id = 0;\r\n        self.generateId = generateId;\r\n\r\n        return {\r\n            subscribe: self.subscribe,\r\n            publish: self.publish\r\n        };\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.event\r\n         * @name subscribe\r\n         * \r\n         * @param {function} callback Event callback\r\n         * @param {boolean} [disposable] Disposable\r\n         * @returns {Object} Subscribtion Token\r\n         * \r\n         * @description \r\n         * Put callback to subscribers list. \r\n         * Return subscription token, so subscriber can unsubscribe.\r\n         * Disposable subscription mean automatical unsubscribe after one call\r\n         */\r\n        function subscribe(callback, disposable) {\r\n            if (callback == undefined) {\r\n                $utils.error.throw('callback must be defined to subscribe for an event');\r\n            } else if (typeof callback !== 'function') {\r\n                $utils.error.throw('callback must be a function to subscribe for an event');\r\n            }\r\n\r\n            var subscriber = {\r\n                id: self.generateId(),\r\n                callback: disposable \r\n                    ? function() {\r\n                        subscriber.unsubscribe();\r\n                        callback();\r\n                    } \r\n                    : callback,\r\n                unsubscribe: self.unsubscribe\r\n            };\r\n\r\n            self.subscribers.push(subscriber);\r\n\r\n            return subscriber;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.event\r\n         * @name unsubscribe\r\n         * \r\n         * @returns {boolean} Is Success\r\n         * \r\n         * @description \r\n         * Delete subscriber from subscribtion list\r\n         */\r\n        function unsubscribe() {\r\n            var index = self.subscribers.indexOf(this);\r\n            if (index === -1) return false;\r\n\r\n            self.subscribers.splice(index, 1);\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.event\r\n         * @name publish\r\n         * \r\n         * @param {Object} data Data\r\n         * \r\n         * @description \r\n         * Call all registered callbacks and pass given data to them\r\n         */\r\n        function publish(data) {\r\n            var subscribers = self.subscribers.slice();\r\n\r\n            for (var i = 0; i < subscribers.length; i++) {\r\n                subscribers[i].callback(data);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.event\r\n         * @name generateId\r\n         * \r\n         * @returns {number} Id\r\n         * \r\n         * @description \r\n         * Generate unique subscribtion id (unique within specific event object)\r\n         */\r\n        function generateId() {\r\n            return self.id++;\r\n        }\r\n    }\r\n})();","(function () {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .filter('translate', ['$translate', translateFilter]);\r\n\r\n    /**\r\n     * @ngdoc filter\r\n     * @name translate.filter:translate\r\n     * @function\r\n     * @requires translate.$translate\r\n     * \r\n     * @param {string} translate_expression Translation key\r\n     * \r\n     * @description \r\n     * Transform translation key into translation\r\n     */\r\n    function translateFilter($translate) {\r\n        var filter = function(key) {\r\n            return $translate.translation(key);\r\n        };\r\n\r\n        filter.$stateful = true;\r\n\r\n        return filter;\r\n    };\r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .factory('$translateLoaderSvc', ['$timeout', '$translateLoader', '$translateEvents', '$translateUtils', translateLoaderSvc]);\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name translate.loaderService\r\n     * @requires $timeout\r\n     * @requires translate.loader\r\n     * @requires translate.events\r\n     * @requires translate.utils\r\n     * \r\n     * @description \r\n     * Service responsible for managing parts loading process\r\n     */\r\n    function translateLoaderSvc($timeout, $translateLoader, $translateEvents, $translateUtils) {\r\n        var self = this;\r\n\r\n        self.config = config;\r\n        self.options = undefined;\r\n        self.storageCallback = undefined;\r\n\r\n        self.parts = [];\r\n\r\n        self.addParts = addParts;\r\n        self.addPart = addPart;\r\n\r\n        self.loadParts = loadParts;\r\n        self.loadPart = loadPart;\r\n\r\n        self.sync = {\r\n            counter: {},\r\n            loading: {},\r\n            loaded: {},\r\n\r\n            loadingOn: loadingOn,\r\n            loadingOff: loadingOff,\r\n            isLoading: isLoading,\r\n            isLoaded: isLoaded,\r\n            needLoad: needLoad,\r\n\r\n            increaseCounter: increaseCounter,\r\n            resetCounter: resetCounter,\r\n            checkCounter: checkCounter\r\n        };\r\n\r\n        self.preload = preload;\r\n\r\n        return self;\r\n\r\n        /* CONFIG */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name config\r\n         * \r\n         * @param {Object} options Options\r\n         * @param {function(string, Object))} storageCallback Storage Callback\r\n         * \r\n         * @description \r\n         * Initialize loader service with configuration info:  \r\n         * - options (url template, data transformation function and preload info)  \r\n         * - storage callback (should receive lang and hashmap and put them to storage)  \r\n         *  \r\n         * Always called by {@link translate.$translate $translate} during initialization process \r\n         */\r\n        function config(options, storageCallback) {\r\n            self.options = options;\r\n            self.storageCallback = storageCallback;\r\n\r\n            $translateEvents.allPartsLoaded.subscribe(self.preload, true);\r\n        }\r\n\r\n        /* PARTS */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name addParts\r\n         * \r\n         * @param {Array<string>} names Part names\r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Add parts to list and start loading them for given language\r\n         */\r\n        function addParts(names, lang) {\r\n            for (var i = 0; i < names.length; i++) {\r\n                self.addPart(names[i], lang);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name addPart\r\n         * \r\n         * @param {string} name Part name\r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Add part to list and start loading it for given language\r\n         */\r\n        function addPart(name, lang) {\r\n            if (typeof name !== 'string') {\r\n                $translateUtils.error.throw('incorrect value for part name');\r\n            }\r\n\r\n            var part = { name: name };\r\n            \r\n            for (var i = 0; i < self.parts.length; i++) {\r\n                if (self.parts[i].name === part.name) return;\r\n            }\r\n\r\n            if (self.parts.indexOf(part) !== -1) return;\r\n\r\n            self.parts.push(part);\r\n\r\n            self.loadPart(part, lang);\r\n        }\r\n        \r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name loadParts\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {boolean} [force] Force \r\n         * \r\n         * @description \r\n         * Start parts loading for given language in non-blocking mode. \r\n         * Before each part-lang pair start loading check if loading for this pair in progress or it already loaded.\r\n         * In this case loading will be prevented. \r\n         * If called with force param, will skip this check.\r\n         */\r\n        function loadParts(lang, force) {\r\n            if (force) {\r\n                self.sync.resetCounter(lang);\r\n            }\r\n\r\n            for (var i = 0; i < self.parts.length; i++) {\r\n                if (!force && !self.sync.needLoad(self.parts[i], lang)) continue;\r\n\r\n                self.loadPart(self.parts[i], lang);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name loadPart\r\n         * \r\n         * @param {Object} part Part\r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Start loading given part for given language. \r\n         * After succesful loading will put received data into storage and fire part loaded event.\r\n         * Also call loading syncronization functions.\r\n         */\r\n        function loadPart(part, lang) {\r\n            self.sync.loadingOn(part, lang);\r\n\r\n            var partOptions = {\r\n                part: part,\r\n                lang: lang,\r\n                urlTemplate: self.options.urlTemplate,\r\n                dataTransformation: self.options.dataTransformation\r\n            };\r\n\r\n            $translateLoader\r\n                .loadPart(partOptions)\r\n                .then(function(values) {\r\n                    self.sync.loadingOff(part, lang);\r\n                    self.sync.increaseCounter(lang);\r\n                    self.sync.checkCounter(lang);\r\n\r\n                    self.storageCallback(lang, values);\r\n\r\n                    $translateEvents.partLoaded.publish({ part: part.name, lang: lang});\r\n                });\r\n        }\r\n\r\n        /* SYNCHRONIZATION */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name loadingOn\r\n         * \r\n         * @param {Object} part Part\r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Mark given part-lang pair as loading in progress\r\n         */\r\n        function loadingOn(part, lang) {\r\n            self.sync.loading[lang + '.' + part.name] = true;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name loadingOff\r\n         * \r\n         * @param {Object} part Part\r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Mark given part-lang pair as loaded\r\n         */\r\n        function loadingOff(part, lang) {\r\n            self.sync.loading[lang + '.' + part.name] = false;\r\n            self.sync.loaded[lang + '.' + part.name] = true;\r\n        }\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name isLoading\r\n         * \r\n         * @param {Object} part Part\r\n         * @param {string} lang Language\r\n         * @returns {boolean} Is Loading\r\n         * \r\n         * @description \r\n         * Return `true` if loading for given part-lang pair in progress\r\n         */\r\n        function isLoading(part, lang) {\r\n            return self.sync.loading[lang + '.' + part.name];\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name isLoaded\r\n         * \r\n         * @param {Object} part Part\r\n         * @param {string} lang Language\r\n         * @returns {boolean} Is Loaded \r\n         * \r\n         * @description \r\n         * Return `true` if given part-lang pair already loaded\r\n         */\r\n        function isLoaded(part, lang) {\r\n            return !!self.sync.loaded[lang + '.' + part.name];\r\n        }\r\n        \r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name increaseCounter\r\n         * \r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Increase parts loaded counter for given language\r\n         */\r\n        function increaseCounter(lang) {\r\n            if (!self.sync.counter[lang]) self.sync.counter[lang] = 1;\r\n            else self.sync.counter[lang]++;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name resetCounter\r\n         * \r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Reset parts loaded counter for given language\r\n         */\r\n        function resetCounter(lang) {\r\n            self.sync.counter[lang] = 0;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name checkCounter\r\n         * \r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Fire all parts loaded event if parts loaded counter for given language equals to parts count\r\n         */\r\n        function checkCounter(lang) {\r\n            if (self.sync.counter[lang] !== self.parts.length) return;\r\n\r\n            $translateEvents.allPartsLoaded.publish({ lang: lang });\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name needLoad\r\n         * \r\n         * @param {Object} part Part\r\n         * @param {string} lang Language\r\n         * @returns {boolean} Is Load Needed\r\n         * \r\n         * @description \r\n         * Check if given part-lang pair require loading. \r\n         * Return `true` if pair loading not in progress and pair not loaded before\r\n         */\r\n        function needLoad(part, lang) {\r\n            return !isLoading(part, lang) && !isLoaded(part, lang);\r\n        }\r\n\r\n        /* PRELOAD */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loaderService\r\n         * @name preload\r\n         * \r\n         * @description \r\n         * Start loading parts for languages in preload list after configured delay.\r\n         * Will called when all parts for some language loaded (only one time).\r\n         * Will not cause loading for already loaded part-lang pairs. \r\n         */\r\n        function preload() {\r\n            if (!self.options.preload.enabled || !self.options.preload.langs) return;\r\n\r\n            $timeout(function () {\r\n                for (var i = 0; i < self.options.preload.langs.length; i++) {\r\n                    var lang = self.options.preload.langs[i];\r\n\r\n                    self.loadParts(lang);\r\n                }\r\n            }, self.options.preload.delay);\r\n        }\r\n    }\r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .factory('$translateLoader', ['$http', '$q', translateLoader]);\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name translate.loader\r\n     * @requires $http\r\n     * @requires $q\r\n     * \r\n     * @description \r\n     * Service responsible for loading parts\r\n     */\r\n    function translateLoader($http, $q) {\r\n        var self = this;\r\n\r\n        self.loadPart = loadPart;\r\n\r\n        return self;\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.loader\r\n         * @name loadPart\r\n         * \r\n         * @param {Object} options Options\r\n         * @returns {Promise} Loading Promise\r\n         * \r\n         * @description \r\n         * Start part loading with given options and return promise.\r\n         * Promise will be resolved after loading complete.\r\n         * Transform received from server data with data transformation function.\r\n         * Transformed data will be passed with promise resolve.\r\n         */\r\n        function loadPart(options) {\r\n            var url = options\r\n                .urlTemplate\r\n                .replace(/{part}/g, options.part.name)\r\n                .replace(/{lang}/g, options.lang);\r\n\r\n            return $q(function (resolve, reject) {\r\n                $http\r\n                    .get(url)\r\n                    .then(function (response) {\r\n                        var values = options.dataTransformation(response.data);\r\n                        resolve(values);\r\n                    })\r\n                    .catch(function (error) {\r\n                        reject(error);\r\n                    });\r\n            });\r\n        }\r\n    };\r\n})();","(function () {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .factory('$translate', ['$translateStorageSvc', '$translateLoaderSvc', '$translateUtils', translate]);\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name translate.$translate\r\n     * @requires translate.storageService\r\n     * @requires translate.loaderService\r\n     * @requires translate.utils\r\n     * \r\n     * @description \r\n     * Service responsible for comunication with external code and manage other parts to work mutually\r\n     */\r\n    function translate($storage, $loader, $utils) {\r\n        var self = this;\r\n\r\n        self.options = {\r\n            dataTransformation: $utils.directDataTransformation,\r\n            keyResolver: $utils.directKeyResolver,\r\n            cache: {\r\n                translations: true,\r\n                lang: true\r\n            },\r\n            preload: {\r\n                enabled: true,\r\n                langs: [],\r\n                delay: 0\r\n            }\r\n        };\r\n        \r\n        self.config = config;\r\n        self.validateOptions = validateOptions;\r\n     \r\n        self.use = use;\r\n        self.current = current;\r\n\r\n        self.translations = translations;\r\n        self.translation = translation;\r\n\r\n        self.addPart = addPart;\r\n        self.addParts = addParts;\r\n\r\n        self.refresh = refresh;\r\n\r\n        return self;\r\n        \r\n        /* INITIALIZATION */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name config\r\n         * \r\n         * @param {Object} options Options\r\n         * \r\n         * @description \r\n         * Merge external options with default library options. \r\n         * Initialize {@link translate.storageService storageService} and {@link translate.loaderService loaderService}\r\n         */\r\n        function config(options) {\r\n            angular.merge(self.options, options);\r\n            self.validateOptions(self.options);\r\n\r\n            $storage.config(self.options);\r\n            $loader.config(self.options, $storage.setTranslations);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name validateOptions\r\n         * \r\n         * @param {Object} options Options\r\n         * \r\n         * @description \r\n         * Throw error if options are corrupt\r\n         */\r\n        function validateOptions(options) {\r\n            // default lang\r\n            if (!options.defaultLang) {\r\n                $utils.error.throw('you didn\\'t specify default language');\r\n            }\r\n\r\n            if (typeof options.defaultLang !== 'string') {\r\n                $utils.error.throw('incorrect value for default language');\r\n            }\r\n\r\n            // url template\r\n            if (!options.urlTemplate) {\r\n                $utils.error.throw('you didn\\'t specify url template');\r\n            }\r\n\r\n            if (typeof options.urlTemplate !== 'string') {\r\n                $utils.error.throw('incorrect value url template');\r\n            }\r\n\r\n            if (options.urlTemplate.indexOf('{lang}') === -1) {\r\n                $utils.error.throw('url template should contain at least {lang} expression');\r\n            }\r\n\r\n            // data transformation\r\n            if (typeof options.dataTransformation !== 'function') {\r\n                $utils.error.throw('incorrect value for data transformation');\r\n            }\r\n\r\n            // cache\r\n            if (typeof options.cache !== 'object') {\r\n                $utils.error.throw('incorrect value for cache');\r\n            }\r\n\r\n            if (typeof options.cache.translations !== 'boolean') {\r\n                $utils.error.throw('incorrect value for cache translations');\r\n            }\r\n\r\n            if (typeof options.cache.lang !== 'boolean') {\r\n                $utils.error.throw('incorrect value for cache language');\r\n            }\r\n\r\n            // preload\r\n            if (typeof options.preload !== 'object') {\r\n                $utils.error.throw('incorrect value for preload');\r\n            }\r\n\r\n            if (typeof options.preload.enabled !== 'boolean') {\r\n                $utils.error.throw('incorrect value for preload enabled');\r\n            }\r\n\r\n            if (Object.prototype.toString.call(options.preload.langs) !== '[object Array]') {\r\n                $utils.error.throw('incorrect value for preload langs');\r\n            }\r\n\r\n            if (typeof options.preload.delay !== 'number') {\r\n                $utils.error.throw('incorrect value for preload delay');\r\n            }\r\n        }\r\n\r\n        /* LANGS */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name use\r\n         * \r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Set current language to given and start loading parts for it.\r\n         * Do nothing if passed language equal to current\r\n         */\r\n        function use(lang) {\r\n            if (typeof lang !== 'string') {\r\n                $utils.error.throw('incorrect value for lang to use');\r\n            }\r\n\r\n            if ($storage.getLang() === lang) return;\r\n\r\n            $storage.setLang(lang);\r\n            $loader.loadParts(lang, false);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name current\r\n         * \r\n         * @returns {string} Language \r\n         * \r\n         * @description \r\n         * Return current language\r\n         */\r\n        function current() {\r\n            return $storage.getLang();\r\n        }\r\n\r\n        /* TRANSLATIONS */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name translations\r\n         * \r\n         * @returns {Object<string, string>} Translations Hashmap \r\n         * \r\n         * @description \r\n         * Return translation hashmap for current language\r\n         */\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name translations\r\n         * \r\n         * @param {string} lang Language\r\n         * @returns {Object<string, string>} Translations Hashmap \r\n         * \r\n         * @description \r\n         * Return translation hashmap for given language\r\n         */\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name translations\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {Object<string, string>} values Translations Hashmap\r\n         * @returns {Object<string, string>} Updated Translations Hashmap \r\n         * \r\n         * @description \r\n         * Put given translations hashmap to storage service for given language.\r\n         * After that return updated translations hashmap for given language\r\n         */\r\n        function translations(lang, values) {\r\n            if (!lang) {\r\n                lang = $storage.getLang();\r\n            }\r\n\r\n            if (!!values) {\r\n                $storage.setTranslations(lang, values);\r\n            }\r\n\r\n            return $storage.getTranslations(lang);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name translation\r\n         * \r\n         * @param {string} key Translation Key\r\n         * @returns {string} Translation\r\n         * \r\n         * @description \r\n         * Return translation for current language and given translation key\r\n         */\r\n        function translation(key) {\r\n            var lang = $storage.getLang();\r\n\r\n            return $storage.getTranslation(lang, key);\r\n        } \r\n\r\n        /* PARTS */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name addParts\r\n         * \r\n         * @param {string} name1 Part Name 1\r\n         * @param {string} [name2] Part Name 2\r\n         * @param {string} [...] ...\r\n         * \r\n         * @description \r\n         * Add parts for current language.\r\n         * Loading will start automatically.\r\n         * Pass part names as separate params\r\n         */\r\n        function addParts() {\r\n            var lang = $storage.getLang();\r\n\r\n            $loader.addParts(arguments, lang);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name addPart\r\n         * \r\n         * @param {string} name Part Name\r\n         * \r\n         * @description \r\n         * Add part for current language.\r\n         * Loading will start automatically\r\n         */\r\n        function addPart(name) {\r\n            var lang = $storage.getLang();\r\n\r\n            $loader.addPart(name, lang);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.$translate\r\n         * @name refresh\r\n         * \r\n         * @param {boolean} force Force\r\n         * \r\n         * @description \r\n         * Call force reload of all added parts for current language\r\n         */\r\n        function refresh(force) {\r\n            var lang = $storage.getLang();\r\n\r\n            $loader.loadParts(lang, force);\r\n        }\r\n    }\r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .factory('$translateStorageSvc', ['$translateStorage', '$translateCache', '$translateEvents', translateStorageSvc]);\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name translate.storageService\r\n     * @requires translate.storage\r\n     * @requires translate.cache\r\n     * @requires translate.events\r\n     * \r\n     * @description \r\n     * Service responsible for managing storing and caching processes\r\n     */\r\n    function translateStorageSvc($translateStorage, $translateCache, $translateEvents) {\r\n        var self = this;\r\n\r\n        self.config = config;\r\n        self.options = undefined;\r\n\r\n        self.cache = {\r\n            get: {\r\n                lang: cacheGetLang,\r\n                translations: cacheGetTranslations\r\n            },\r\n            set: {\r\n                lang: cacheSetLang,\r\n                translations: cacheSetTranslations\r\n            }\r\n        };\r\n\r\n        self.storage = {\r\n            get: {\r\n                lang: storageGetLang,\r\n                translations: storageGetTranslations,\r\n                translation: storageGetTranslation\r\n            },\r\n            set: {\r\n                lang: storageSetLang,\r\n                translations: storageSetTranslations\r\n            }\r\n        };\r\n\r\n        self.setTranslations = setTranslations;\r\n        self.getTranslations = getTranslations;\r\n        self.getTranslation = getTranslation;\r\n\r\n        self.setLang = setLang;\r\n        self.getLang = getLang;\r\n\r\n        return self;\r\n\r\n        /* CONFIG */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService\r\n         * @name config\r\n         * \r\n         * @param {Object} options Options\r\n         * \r\n         * @description \r\n         * Initialize storage service with options (cache info and default language).\r\n         * Choose language to work and load translations from cache.\r\n         * Always called by {@link translate.$translate $translate} during initialization process \r\n         */\r\n        function config(options) {\r\n            self.options = options;\r\n\r\n            var lang = self.cache.get.lang();\r\n            var translations = self.cache.get.translations(lang);\r\n\r\n            self.storage.set.lang(lang);\r\n            self.storage.set.translations(lang, translations);\r\n        }\r\n\r\n        /* TRANSLATIONS */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name setTranslations\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {Object<string, string>} values Translations Hashmap\r\n         * \r\n         * @description \r\n         * Put given translations for given language into storage and cache. \r\n         * Fire translations updated event\r\n         */\r\n        function setTranslations(lang, values) {\r\n            self.storage.set.translations(lang, values);\r\n            self.cache.set.translations(lang, values);\r\n\r\n            $translateEvents.translationsUpdated.publish({ lang: lang });\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name getTranslations\r\n         * \r\n         * @param {string} lang Language\r\n         * @returns {Object<string, string>} Translations Hashmap \r\n         * \r\n         * @description \r\n         * Return translations hashmap for given language from storage\r\n         */\r\n        function getTranslations(lang) {\r\n            return self.storage.get.translations(lang);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name getTranslation\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {string} key Translation key\r\n         * @returns {string} Translation\r\n         * \r\n         * @description \r\n         * Return translation for given language and translation key.\r\n         * If translation with this key not exist will use key resolver\r\n         */\r\n        function getTranslation(lang, key) {\r\n            return self.storage.get.translation(lang, key);\r\n        }\r\n\r\n        /* LANGUAGE */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name setLang\r\n         * \r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Put given language to cache and storage.\r\n         * Load translations for new language from cache to storage.\r\n         * Fire language changed event\r\n         */\r\n        function setLang(lang) {\r\n            var oldLang = self.storage.get.lang();\r\n\r\n            self.storage.set.lang(lang);\r\n            self.cache.set.lang(lang);\r\n\r\n            if (!$translateStorage.exists(lang)) {\r\n                var translations = self.cache.get.translations(lang);\r\n                self.storage.set.translations(lang, translations);\r\n            }\r\n\r\n            $translateEvents.langChanged.publish({ from: oldLang, to: lang });\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name getLang\r\n         * \r\n         * @returns {string} Language \r\n         * \r\n         * @description \r\n         * Return language from storage\r\n         */\r\n        function getLang() {\r\n            return self.storage.get.lang();\r\n        }\r\n\r\n        /* CACHE */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name cacheGetLang\r\n         * \r\n         * @returns {string} Language \r\n         * \r\n         * @description \r\n         * Return language from cache. \r\n         * If cache disabled will return default language\r\n         */\r\n        function cacheGetLang() {\r\n            var lang = undefined;\r\n\r\n            if (self.options.cache.lang) {\r\n                lang = $translateCache.getLang();\r\n            }\r\n\r\n            if (!lang) {\r\n                lang = self.options.defaultLang;\r\n            }\r\n\r\n            return lang;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name cacheSetLang\r\n         * \r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Put language to cache if it enabled\r\n         */\r\n        function cacheSetLang(lang) {\r\n            if (!self.options.cache.lang) return;\r\n\r\n            $translateCache.setLang(lang);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name cacheGetTranslations\r\n         * \r\n         * @param {string} lang Language\r\n         * @returns {Object<string, string>} Translations Hashmap\r\n         * \r\n         * @description \r\n         * Return translations hashmap for given language from cache.\r\n         * If cache disabled will return empty object\r\n         */\r\n        function cacheGetTranslations(lang) {\r\n            if (!self.options.cache.translations) return {};\r\n\r\n            return $translateCache.getValues(lang);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name cacheSetTranslations\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {Object<string, string>} values Translations Hashmap\r\n         * \r\n         * @description \r\n         * Put given translations hashmap for given language to cache if it enabled\r\n         */\r\n        function cacheSetTranslations(lang, values) {\r\n            if (!self.options.cache.translations) return;\r\n\r\n            $translateCache.setValues(lang, values);\r\n        }\r\n\r\n        /* STORAGE */\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name storageGetLang\r\n         * \r\n         * @returns {string} Language \r\n         * \r\n         * @description \r\n         * Return language from storage (decorate options.lang)\r\n         */\r\n        function storageGetLang() {\r\n            return self.options.lang;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name storageSetLang\r\n         * \r\n         * @param {string} lang Language\r\n         * \r\n         * @description \r\n         * Put given language to storage (decorate options.lang)\r\n         */\r\n        function storageSetLang(lang) {\r\n            self.options.lang = lang;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name storageGetTranslations\r\n         * \r\n         * @param {string} lang Language\r\n         * @returns {Object<string, string>} Translations Hashmap\r\n         * \r\n         * @description \r\n         * Return translations hashmap for given language from storage\r\n         */\r\n        function storageGetTranslations(lang) {\r\n            return $translateStorage.getValues(lang);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService \r\n         * @name storageGetTranslation\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {string} key Translation Key\r\n         * @returns {string} Translation \r\n         * \r\n         * @description \r\n         * Return translation for given translation key and language from storage\r\n         */\r\n        function storageGetTranslation(lang, key) {\r\n            return $translateStorage.getValue(lang, key, self.options.keyResolver);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storageService\r\n         * @name storageSetTranslations\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {Object<string, string>} values Translations Hashmap\r\n         * \r\n         * @description \r\n         * Put given translations hashmap for given language to storage\r\n         */\r\n        function storageSetTranslations(lang, values) {\r\n            $translateStorage.setValues(lang, values);\r\n        }\r\n    }\r\n})();","(function () {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .factory('$translateStorage', [translateStorage]);\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name translate.storage\r\n     * \r\n     * @description \r\n     * Service responsible for storing the translations data while app is running\r\n     */\r\n    function translateStorage() {\r\n        var self = this;\r\n\r\n        self.langs = {};\r\n\r\n        self.getValues = getValues;\r\n        self.getValue = getValue;\r\n        self.setValues = setValues;\r\n\r\n        self.exists = exists;\r\n\r\n        return self;\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storage\r\n         * @name getValues\r\n         * \r\n         * @param {string} lang Language\r\n         * @returns {Object.<string, string>} Values Hashmap\r\n         * \r\n         * @description \r\n         * Return values hashmap for given language\r\n         */\r\n        function getValues(lang) {\r\n            if (!self.exists(lang)) {\r\n                self.langs[lang] = {};\r\n            }\r\n\r\n            return self.langs[lang];\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storage\r\n         * @name getValue\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {string} key Key\r\n         * @returns {string} Value\r\n         * \r\n         * @description \r\n         * Return value by key from language hashmap\r\n         */\r\n        function getValue(lang, key, resolver) {\r\n            if (!self.exists(lang, key)) {\r\n                if (typeof resolver === 'function') {\r\n                    return resolver(key);\r\n                } else {\r\n                    return key;\r\n                }\r\n            }\r\n\r\n            return self.langs[lang][key];\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storage\r\n         * @name setValues\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {Object.<string, string>} values Values Hashmap\r\n         * \r\n         * @description \r\n         * Merge existing hashmap for given language with passed hashmap. \r\n         * If hashmap not exists, will create empty object first\r\n         */\r\n        function setValues(lang, values) {\r\n            if (!self.langs.hasOwnProperty(lang)) {\r\n                self.langs[lang] = {};\r\n            }\r\n\r\n            angular.merge(self.langs[lang], values);\r\n        }\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.storage\r\n         * @name exists\r\n         * \r\n         * @param {string} lang Language\r\n         * @param {string} key Key\r\n         * @returns {boolean} Is Exists\r\n         * \r\n         * @description \r\n         * Check if key exists in language hashmap \r\n         */\r\n        function exists(lang, key) {\r\n            if (!self.langs.hasOwnProperty(lang)) return false;\r\n\r\n            if (!!key && !self.langs[lang].hasOwnProperty(key)) return false;\r\n\r\n            return true;\r\n        }\r\n    };\r\n})();","(function() {\r\n    'use strict';\r\n\r\n    angular\r\n        .module('mutant-ng-translate')\r\n        .factory('$translateUtils', [tranlslateUtils]);\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name translate.utils\r\n     * \r\n     * @description \r\n     * Service provides some utility functions like errors, warnings and etc.\r\n     */\r\n    function tranlslateUtils() {\r\n        var self = this;\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.utils\r\n         * @name directDataTransformation\r\n         * \r\n         * @param {Object} values Values\r\n         * @returns {Object} Transformed Values\r\n         * \r\n         * @description \r\n         * Return passed values without changes. \r\n         * Used for default transformation of received translations data\r\n         */\r\n        self.directDataTransformation = function (values) {\r\n            return values;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.utils\r\n         * @name directKeyResolver\r\n         * \r\n         * @param {string} key Key\r\n         * @returns {string} Value\r\n         * \r\n         * @description \r\n         * Return passed key without changes.\r\n         * Used for default key resolving when external code require non existing key\r\n         */\r\n        self.directKeyResolver = function (key) {\r\n            return key;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.utils\r\n         * @name errorThrow\r\n         * \r\n         * @description \r\n         * Throw error with library prefix\r\n         * \r\n         * @example \r\n         * ```javascript\r\n         * $translateUtils.error.throw('error message');\r\n         * ```\r\n         */\r\n        self.error = {\r\n            prefix: '[mutant-ng-translate]: ',\r\n            throw: function (message) {\r\n                throw new Error(self.error.prefix + message);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * @ngdoc method\r\n         * @methodOf translate.utils\r\n         * @name warningThrow\r\n         * \r\n         * @description \r\n         * Write warning with library prefix\r\n         * \r\n         * @example \r\n         * ```javascript\r\n         * $translateUtils.warning.throw('error message');\r\n         * ```\r\n         */\r\n        self.warning = {\r\n            write: console != undefined\r\n                && console.warn != undefined\r\n                && typeof console.warn === 'function'\r\n                ? console.warn\r\n                : function() {},\r\n            throw: function(message) {\r\n                self.warning.write(self.error.prefix + message);\r\n            }\r\n        };\r\n\r\n        return self;\r\n    };\r\n})();"],"sourceRoot":"/source/"}